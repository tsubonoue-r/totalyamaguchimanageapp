#!/usr/bin/env ts-node
/**
 * Miyabi Documentation Generator
 *
 * ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’è§£æã—ã¦APIãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’è‡ªå‹•ç”Ÿæˆã—ã¾ã™ã€‚
 */

import * as fs from 'fs';
import * as path from 'path';

interface DocSection {
  title: string;
  content: string;
}

interface FileInfo {
  path: string;
  name: string;
  type: 'component' | 'page' | 'api' | 'hook' | 'lib' | 'type' | 'other';
  exports: string[];
  description?: string;
}

const SRC_DIR = path.join(process.cwd(), 'src');
const OUTPUT_FILE = path.join(process.cwd(), 'docs', 'API.md');

/**
 * ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
 */
function getFileType(filePath: string): FileInfo['type'] {
  if (filePath.includes('/components/')) return 'component';
  if (filePath.includes('/app/') && filePath.includes('/api/')) return 'api';
  if (filePath.includes('/app/')) return 'page';
  if (filePath.includes('/hooks/')) return 'hook';
  if (filePath.includes('/lib/')) return 'lib';
  if (filePath.includes('/types/')) return 'type';
  return 'other';
}

/**
 * TypeScript/TSXãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰exportã‚’æŠ½å‡º
 */
function extractExports(content: string): string[] {
  const exports: string[] = [];

  // export function/const/class
  const exportRegex = /export\s+(default\s+)?(function|const|class|interface|type)\s+(\w+)/g;
  let match;
  while ((match = exportRegex.exec(content)) !== null) {
    exports.push(match[3]);
  }

  // export default
  const defaultExport = content.match(/export\s+default\s+(\w+)/);
  if (defaultExport && !exports.includes(defaultExport[1])) {
    exports.push(defaultExport[1]);
  }

  return exports;
}

/**
 * ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰JSDocã‚³ãƒ¡ãƒ³ãƒˆã‚’æŠ½å‡º
 */
function extractDescription(content: string): string | undefined {
  const jsdocMatch = content.match(/\/\*\*\s*\n([^*]|\*[^/])*\*\//);
  if (jsdocMatch) {
    return jsdocMatch[0]
      .replace(/\/\*\*|\*\//g, '')
      .replace(/^\s*\*\s?/gm, '')
      .trim()
      .split('\n')[0];
  }
  return undefined;
}

/**
 * ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å†å¸°çš„ã«èµ°æŸ»
 */
function scanDirectory(dir: string): FileInfo[] {
  const files: FileInfo[] = [];

  if (!fs.existsSync(dir)) {
    return files;
  }

  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      files.push(...scanDirectory(fullPath));
    } else if (entry.name.match(/\.(ts|tsx)$/) && !entry.name.includes('.test.') && !entry.name.includes('.spec.')) {
      const content = fs.readFileSync(fullPath, 'utf-8');
      files.push({
        path: fullPath.replace(process.cwd(), ''),
        name: entry.name,
        type: getFileType(fullPath),
        exports: extractExports(content),
        description: extractDescription(content),
      });
    }
  }

  return files;
}

/**
 * Markdownã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆ
 */
function generateSection(title: string, files: FileInfo[]): DocSection {
  if (files.length === 0) {
    return { title, content: '' };
  }

  let content = `## ${title}\n\n`;

  for (const file of files) {
    content += `### \`${file.path}\`\n\n`;

    if (file.description) {
      content += `${file.description}\n\n`;
    }

    if (file.exports.length > 0) {
      content += `**Exports:**\n`;
      for (const exp of file.exports) {
        content += `- \`${exp}\`\n`;
      }
      content += '\n';
    }
  }

  return { title, content };
}

/**
 * ãƒ¡ã‚¤ãƒ³å‡¦ç†
 */
function main() {
  console.log('ğŸ“š ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆç”Ÿæˆã‚’é–‹å§‹...\n');

  const files = scanDirectory(SRC_DIR);

  const components = files.filter(f => f.type === 'component');
  const pages = files.filter(f => f.type === 'page');
  const apis = files.filter(f => f.type === 'api');
  const hooks = files.filter(f => f.type === 'hook');
  const libs = files.filter(f => f.type === 'lib');
  const types = files.filter(f => f.type === 'type');

  let markdown = `# API Documentation\n\n`;
  markdown += `> Generated by Miyabi Doc Generator\n\n`;
  markdown += `> Last updated: ${new Date().toISOString()}\n\n`;
  markdown += `---\n\n`;

  // ç›®æ¬¡
  markdown += `## ç›®æ¬¡\n\n`;
  if (components.length > 0) markdown += `- [Components](#components)\n`;
  if (pages.length > 0) markdown += `- [Pages](#pages)\n`;
  if (apis.length > 0) markdown += `- [API Routes](#api-routes)\n`;
  if (hooks.length > 0) markdown += `- [Hooks](#hooks)\n`;
  if (libs.length > 0) markdown += `- [Libraries](#libraries)\n`;
  if (types.length > 0) markdown += `- [Types](#types)\n`;
  markdown += `\n---\n\n`;

  // å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³
  const sections = [
    generateSection('Components', components),
    generateSection('Pages', pages),
    generateSection('API Routes', apis),
    generateSection('Hooks', hooks),
    generateSection('Libraries', libs),
    generateSection('Types', types),
  ];

  for (const section of sections) {
    if (section.content) {
      markdown += section.content;
      markdown += '---\n\n';
    }
  }

  // çµ±è¨ˆ
  markdown += `## çµ±è¨ˆ\n\n`;
  markdown += `| ã‚«ãƒ†ã‚´ãƒª | ãƒ•ã‚¡ã‚¤ãƒ«æ•° |\n`;
  markdown += `|---------|----------|\n`;
  markdown += `| Components | ${components.length} |\n`;
  markdown += `| Pages | ${pages.length} |\n`;
  markdown += `| API Routes | ${apis.length} |\n`;
  markdown += `| Hooks | ${hooks.length} |\n`;
  markdown += `| Libraries | ${libs.length} |\n`;
  markdown += `| Types | ${types.length} |\n`;
  markdown += `| **Total** | **${files.length}** |\n`;

  // å‡ºåŠ›
  const outputDir = path.dirname(OUTPUT_FILE);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(OUTPUT_FILE, markdown);

  console.log(`âœ… ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆç”Ÿæˆå®Œäº†!`);
  console.log(`ğŸ“„ å‡ºåŠ›: ${OUTPUT_FILE}`);
  console.log(`ğŸ“Š ${files.length} ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡¦ç†ã—ã¾ã—ãŸ`);
}

main();
